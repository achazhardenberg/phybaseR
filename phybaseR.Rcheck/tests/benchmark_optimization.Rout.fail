
R version 4.5.2 (2025-10-31) -- "[Not] Part in a Rumble"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: aarch64-apple-darwin20

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(phybaseR)
> library(nimble)
nimble version 1.3.0 is loaded.
For more information on NIMBLE and a User Manual,
please visit https://R-nimble.org.

Note for advanced users who have written their own MCMC samplers:
  As of version 0.13.0, NIMBLE's protocol for handling posterior
  predictive nodes has changed in a way that could affect user-defined
  samplers in some situations. Please see Section 15.5.1 of the User Manual.

Attaching package: 'nimble'

The following object is masked from 'package:stats':

    simulate

The following object is masked from 'package:base':

    declare

> library(rjags)
Loading required package: coda
Linked to JAGS 4.3.2
Loaded modules: basemod,bugs
> 
> # Load rhino data
> data("rhino.dat")
> data("rhino.tree")
> 
> data_list <- list(
+     BM = rhino.dat$BM,
+     NL = rhino.dat$NL,
+     DD = rhino.dat$DD
+ )
> 
> equations <- list(
+     NL ~ BM,
+     DD ~ NL
+ )
> 
> cat("\n=== 3-Way Benchmark: JAGS (Marginal) vs JAGS (Latent) vs NIMBLE ===\n\n")

=== 3-Way Benchmark: JAGS (Marginal) vs JAGS (Latent) vs NIMBLE ===

> 
> # ============================================================================
> # 1. JAGS (Marginal) - Current Implementation
> # ============================================================================
> cat("--- 1. JAGS (Marginal/Current) - 1000 iterations ---\n")
--- 1. JAGS (Marginal/Current) - 1000 iterations ---
> time_jags_marginal <- system.time({
+     fit_jags_marginal <- phybase_run(
+         data = data_list,
+         tree = rhino.tree,
+         equations = equations,
+         n.iter = 1000,
+         n.burnin = 200,
+         n.thin = 2,
+         parallel = FALSE,
+         WAIC = FALSE,
+         DIC = FALSE,
+         quiet = TRUE
+     )
+ })
Warning message:
In rjags::jags.model(model_file, data = data, n.chains = n.chains,  :
  Unused variable "ID2" in data
> cat(sprintf(
+     "JAGS (Marginal) Time: %.2f seconds\n",
+     time_jags_marginal["elapsed"]
+ ))
JAGS (Marginal) Time: 9.28 seconds
> 
> # ============================================================================
> # 2. JAGS (Latent) - Optimized Implementation
> # ============================================================================
> cat("\n--- 2. JAGS (Latent/Optimized) - 1000 iterations ---\n")

--- 2. JAGS (Latent/Optimized) - 1000 iterations ---
> 
> N <- length(rhino.tree$tip.label)
> vcv_tree <- ape::vcv(rhino.tree)
> Prec_phylo_fixed <- solve(vcv_tree)
> 
> # Define JAGS model manually
> jags_latent_code <- "
+ model {
+   # Priors
+   alphaBM ~ dnorm(0, 0.001)
+   alphaNL ~ dnorm(0, 0.001)
+   alphaDD ~ dnorm(0, 0.001)
+   betaBM ~ dnorm(0, 0.001)
+   betaNL ~ dnorm(0, 0.001)
+   
+   tau_u_BM ~ dgamma(0.001, 0.001)
+   tau_e_BM ~ dgamma(0.001, 0.001)
+   tau_u_NL ~ dgamma(0.001, 0.001)
+   tau_e_NL ~ dgamma(0.001, 0.001)
+   tau_u_DD ~ dgamma(0.001, 0.001)
+   tau_e_DD ~ dgamma(0.001, 0.001)
+ 
+   # Latent effects (Standardized)
+   u_std_BM[1:N] ~ dmnorm(zeros[1:N], Prec_phylo_fixed[1:N, 1:N])
+   u_std_NL[1:N] ~ dmnorm(zeros[1:N], Prec_phylo_fixed[1:N, 1:N])
+   u_std_DD[1:N] ~ dmnorm(zeros[1:N], Prec_phylo_fixed[1:N, 1:N])
+ 
+   for(i in 1:N) {
+     # Scale effects
+     u_BM[i] <- u_std_BM[i] / sqrt(tau_u_BM)
+     u_NL[i] <- u_std_NL[i] / sqrt(tau_u_NL)
+     u_DD[i] <- u_std_DD[i] / sqrt(tau_u_DD)
+     
+     # Linear predictors
+     mu_BM[i] <- alphaBM
+     mu_NL[i] <- alphaNL + betaBM * BM[i]
+     mu_DD[i] <- alphaDD + betaNL * NL[i]
+     
+     # Likelihoods
+     BM[i] ~ dnorm(mu_BM[i] + u_BM[i], tau_e_BM)
+     NL[i] ~ dnorm(mu_NL[i] + u_NL[i], tau_e_NL)
+     DD[i] ~ dnorm(mu_DD[i] + u_DD[i], tau_e_DD)
+   }
+ }
+ "
> 
> jags_data <- c(
+     data_list,
+     list(N = N, Prec_phylo_fixed = Prec_phylo_fixed, zeros = rep(0, N))
+ )
> jags_inits <- list(
+     alphaBM = 0,
+     alphaNL = 0,
+     alphaDD = 0,
+     betaBM = 0,
+     betaNL = 0,
+     tau_u_BM = 1,
+     tau_e_BM = 1,
+     tau_u_NL = 1,
+     tau_e_NL = 1,
+     tau_u_DD = 1,
+     tau_e_DD = 1
+ )
> 
> time_jags_latent <- system.time({
+     model_jags <- jags.model(
+         textConnection(jags_latent_code),
+         data = jags_data,
+         inits = jags_inits,
+         n.chains = 1,
+         quiet = TRUE
+     )
+     update(model_jags, 200) # burnin
+     samples_jags <- coda.samples(
+         model_jags,
+         variable.names = c("betaBM", "betaNL"),
+         n.iter = 1000,
+         thin = 2
+     )
+ })
> cat(sprintf("JAGS (Latent) Time: %.2f seconds\n", time_jags_latent["elapsed"]))
JAGS (Latent) Time: 7.69 seconds
> 
> # ============================================================================
> # 3. NIMBLE (Latent) - Reference
> # ============================================================================
> cat("\n--- 3. NIMBLE (Latent) - 1000 iterations ---\n")

--- 3. NIMBLE (Latent) - 1000 iterations ---
> 
> nimble_code <- nimbleCode({
+     alphaBM ~ dnorm(0, 0.001)
+     alphaNL ~ dnorm(0, 0.001)
+     alphaDD ~ dnorm(0, 0.001)
+     betaBM ~ dnorm(0, 0.001)
+     betaNL ~ dnorm(0, 0.001)
+ 
+     tau_u_BM ~ dgamma(0.001, 0.001)
+     tau_e_BM ~ dgamma(0.001, 0.001)
+     tau_u_NL ~ dgamma(0.001, 0.001)
+     tau_e_NL ~ dgamma(0.001, 0.001)
+     tau_u_DD ~ dgamma(0.001, 0.001)
+     tau_e_DD ~ dgamma(0.001, 0.001)
+ 
+     u_std_BM[1:N] ~ dmnorm(zeros[1:N], prec = Prec_phylo_fixed[1:N, 1:N])
+     u_std_NL[1:N] ~ dmnorm(zeros[1:N], prec = Prec_phylo_fixed[1:N, 1:N])
+     u_std_DD[1:N] ~ dmnorm(zeros[1:N], prec = Prec_phylo_fixed[1:N, 1:N])
+ 
+     for (i in 1:N) {
+         u_BM[i] <- u_std_BM[i] / sqrt(tau_u_BM)
+         u_NL[i] <- u_std_NL[i] / sqrt(tau_u_NL)
+         u_DD[i] <- u_std_DD[i] / sqrt(tau_u_DD)
+ 
+         mu_BM[i] <- alphaBM
+         mu_NL[i] <- alphaNL + betaBM * BM[i]
+         mu_DD[i] <- alphaDD + betaNL * NL[i]
+ 
+         BM[i] ~ dnorm(mu_BM[i] + u_BM[i], tau_e_BM)
+         NL[i] ~ dnorm(mu_NL[i] + u_NL[i], tau_e_NL)
+         DD[i] ~ dnorm(mu_DD[i] + u_DD[i], tau_e_DD)
+     }
+ })
> 
> time_nimble <- system.time({
+     nimble_model <- nimbleModel(
+         code = nimble_code,
+         constants = list(
+             N = N,
+             Prec_phylo_fixed = Prec_phylo_fixed,
+             zeros = rep(0, N)
+         ),
+         data = data_list,
+         inits = jags_inits
+     )
+     c_nimble <- compileNimble(nimble_model)
+     mcmc_conf <- configureMCMC(nimble_model, monitors = c("betaBM", "betaNL"))
+     mcmc <- buildMCMC(mcmc_conf)
+     c_mcmc <- compileNimble(mcmc, project = nimble_model)
+     nimble_samples <- runMCMC(
+         c_mcmc,
+         niter = 1000,
+         nburnin = 200,
+         thin = 2,
+         nchains = 1,
+         setSeed = 123
+     )
+ })
Defining model
Building model
Setting data and initial values
Running calculate on model
  [Note] Any error reports that follow may simply reflect missing values in model variables.
Checking model sizes and dimensions
  [Note] This model is not fully initialized. This is not an error.
         To see which variables are not initialized, use model$initializeInfo().
         For more information on model initialization, see help(modelInitialization).
Compiling
  [Note] This may take a minute.
  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.
Error: Failed to create the shared library. Run 'printErrors()' to see the compilation errors.
Timing stopped at: 7.719 0.117 7.918
Execution halted
