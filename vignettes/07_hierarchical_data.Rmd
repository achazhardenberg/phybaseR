---
title: "Hierarchical Data Structures"
author: "Achaz von Hardenberg"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Hierarchical Data Structures}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>", eval = FALSE
)
```

# Hierarchical Data Structures

When variables are measured at different hierarchical levels, because automatically handles sample size management to prevent inflation and ensure correct statistical inference.

## The Problem: Sample Size Inflation

**Scenario**: You have measurements at different hierarchical levels:
- **Individual level**: body mass, age (100 observations)  
- **Site-year level**: temperature, rainfall (4 unique site-year combinations, but replicated across 100 individuals)

**Without proper handling**: Testing `temperature ~ rainfall` would use 100 observations when you really only have 4 unique data points. This inflates sample size and underestimates uncertainty.

## The Solution

because automatically uses the appropriate dataset for each model and test.

### Basic Setup

```{r, eval=FALSE}
# Individual-level data (finest grain)
individual_data <- data.frame(
    individual_id = 1:100,
    site = rep(c("A", "B"), each = 50),
    year = rep(c(2020, 2021), 50),
    body_mass = rnorm(100, 50, 10),
    age = rnorm(100, 5, 2)
)

# Site-year level data (only 4 unique combinations!)
site_year_data <- data.frame(
    site = c("A", "A", "B", "B"),
    year = c(2020, 2021, 2020, 2021),
    temperature = c(15, 16, 17, 18),
    rainfall = c(800, 850, 900, 950)
)

# Specify hierarchical structure
fit <- because(
    data = list(
        individual = individual_data,
        site_year = site_year_data
    ),
    levels = list(
        individual = c("body_mass", "age"),
        site_year = c("temperature", "rainfall")
    ),
    hierarchy = "site_year > individual",
    link_vars = c("site", "year"),
    equations = list(
        body_mass ~ age + temperature,
        age ~ rainfall
    ),
    dsep = TRUE
)
```

## How It Works

### 1. Main Model Run

because automatically joins the datasets:

```r
# Internally creates:
# - Joins site_year_data to individual_data using site + year
# - Result: 100 observations with all variables
```

### 2. D-Separation Tests

Each test uses the appropriate dataset:

| Test | Variables | Dataset Used | N |
|------|-----------|--------------|---|
| `body_mass _||_ rainfall \| age, temp` | Mixed levels | Joined | 100 |
| `age _||_ temperature \| rainfall` | Mixed levels | Joined | 100 |
| **`temperature _||_ rainfall \| `** | **Site-year only** | **site_year** | **4** ✓ |

**Key benefit**: The test between site-year variables correctly uses only 4 observations!

## Parameters Explained

### `data`
A named list of data.frames, one per hierarchical level:

```r
data = list(
  individual = individual_df,
  site_year = site_year_df
)
```

### `levels`
Maps variables to their hierarchical level:

```r
levels = list(
  individual = c("body_mass", "age", "sex"),
  site_year = c("temperature", "rainfall", "elevation")
)
```

### `hierarchy`
Specifies the nesting structure (coarse to fine):

```r
hierarchy = "site_year > individual"
```

For more complex nesting:

```r
hierarchy = "region > site > plot > individual"
```

### `link_vars`
Variables that link the hierarchical levels:

```r
link_vars = c("site", "year")  # Must be present in ALL datasets
```

## Common Use Cases

### Ecological Field Data

```{r, eval=FALSE}
# Plot-level: soil, vegetation
# Individual-level: plant traits

fit <- because(
    data = list(
        plot = plot_data,
        individual = plant_data
    ),
    levels = list(
        plot = c("soil_pH", "canopy_cover"),
        individual = c("height", "leaf_area")
    ),
    hierarchy = "plot > individual",
    link_vars = "plot_id"
)
```

### Longitudinal Studies

```{r, eval=FALSE}
# Year-level: climate
# Visit-level: measurements

fit <- because(
    data = list(
        year = yearly_climate,
        visit = individual_visits
    ),
    levels = list(
        year = c("temperature", "rainfall"),
        visit = c("weight", "condition")
    ),
    hierarchy = "year > visit",
    link_vars = "year"
)
```

### Spatial Hierarchy

```{r, eval=FALSE}
# Region > Site > Quadrat

fit <- because(
    data = list(
        region = region_data,
        site = site_data,
        quadrat = quadrat_data
    ),
    levels = list(
        region = c("climate_zone"),
        site = c("elevation", "soil_type"),
        quadrat = c("species_count", "biomass")
    ),
    hierarchy = "region > site > quadrat",
    link_vars = c("region_id", "site_id")
)
```

## Validation

because automatically validates:

✅ All level names in `levels` exist in `data`  
✅ All variables exist in their specified datasets  
✅ No variable appears in multiple levels  
✅ Link variables exist in all datasets  
✅ Hierarchy levels match data structure  

## Combining with Random Effects

Hierarchical data works seamlessly with random effects:

```{r, eval=FALSE}
fit <- because(
    data = list(
        site = site_data,
        individual = individual_data
    ),
    levels = list(
        site = c("habitat_quality"),
        individual = c("body_mass", "age")
    ),
    hierarchy = "site > individual",
    link_vars = "site_id",
    random = ~ (1 | site_id), # Random site effects
    equations = list(
        body_mass ~ age + habitat_quality
    )
)
```

**Note**: The `hierarchy` parameter specifies DATA levels (which dataset to use). The `random` parameter specifies MODEL structure (random grouping).

## Troubleshooting

### Error: "Hierarchy levels not found in data"

**Cause**: Level name mismatch

```r
# Wrong
hierarchy = "site > individual"
data = list(site_level = ..., indiv = ...)  # Names don't match!

# Right
hierarchy = "site_level > indiv"
```

### Error: "Variables not found"

**Cause**: Variable assigned to wrong level

```r
# Check that each variable is in its specified dataset
levels = list(
  site = c("temperature"),  # Must be in site dataset!
  individual = c("age")      # Must be in individual dataset!
)
```

### Warning: "Unexpected sample size"

**Cause**: Duplicated rows in higher-level data

```r
# Wrong - should have only 4 unique site-year combinations
site_year_data <- data.frame(
  site = c("A", "A", "A", "A", "B", "B", "B", "B"),
  year = c(2020, 2020, 2021, 2021, 2020, 2020, 2021, 2021),  # Duplicates!
  temp = c(15, 15, 16, 16, 17, 17, 18, 18)
)

# Right - one row per unique combination
site_year_data <- data.frame(
  site = c("A", "A", "B", "B"),
  year = c(2020, 2021, 2020, 2021),
  temp = c(15, 16, 17, 18)
)
```

## Simplified Workflow: Using Long-Format Data Directly

If you have repeated measures for species (e.g., a "long" dataframe where each row is an individual observation), you can now use `because()` directly without manually splitting or formatting your data.

**Requirements**:
1.  **`id_col`**: You must specify the column name that links rows to the phylogenetic tree (e.g., "Species").
2.  **`variability`**: You must explicitly tell the model which variables have repeated measures using `c(TraitName = "reps")`.
    *   **Include**: Any trait that varies within species (e.g., body mass, length).
    *   **Do NOT Include**: Constant variables (grouping factors like Sex, Diet) - these are handled automatically.

### Example

Suppose `long_data` contains 500 rows for 100 species, measuring `body_mass` multiple times per species.

```r
# No need to manually create matrices!
fit <- because(
    data = long_data,
    tree = tree,
    id_col = "Species",                     # Maps data rows to tree tips
    variability = c(body_mass = "reps"),    # Tells model to treat this as replicated
    equations = list(
        body_mass ~ age + temperature       # Underlying relationship
    )
)
```

**What Happens Internally:**
1.  `because` automatically detects the long format.
2.  It converts `body_mass` into a species x replicates matrix (`body_mass_obs`).
3.  It converts constant variables (like `Species`, `Diet`) into species-level vectors.
4.  It fits the Measurement Error model (`body_mass_obs ~ N(body_mass_true, error)`).

This is ideal for Measurement Error models, where you want to account for observation noise in your predictors or responses.

## Combining Measurement Error and Random Effects

One of the most powerful features of `because` is the ability to combine **Measurement Error models** (for individual variability) with **Random Effects** (for group-level clustering) in the same analysis.

This allows you to simultaneously:
1.  **De-noise your predictors**: Use `variability` to estimate true latent traits from noisy replicates.
2.  **Account for grouping**: Use `random` to control for shared environmental or taxonomic effects (e.g., Diet, Location).

### Key Distinction

*   **`variability`**: Use this when you have repeated measurements of the same individual/species that inform the **true state** of a trait (e.g., estimating True Body Mass from 5 weighings). This cleans up measurement error and prevents attenuation bias.
*   **`random`**: Use this for **grouping factors** (e.g., Diet, Location, Year) to account for **shared variance** or clustering, without implying you are estimating a "true latent value" for the group itself.

### Example: The "Ultimate" Model

Imagine testing if *True Body Mass* affects *Lifespan*, while controlling for *Diet* and *Phylogeny*:

```r
fit <- because(
    data = long_data,
    tree = tree,
    id_col = "Species",
    
    # 1. Measurement Error Component (Input Side)
    #    Handles noise in Body Mass using replicates
    variability = c(body_mass = "reps"),
    
    # 2. Random Effects Component (Structure Side)
    #    Handles clustering by Diet
    random = ~ (1 | Diet),
    
    # 3. Structural Equation (The Relationship)
    equations = list(
        lifespan ~ body_mass
    )
)
```

**What this model does:**
$$BM_{obs,ij} \sim \mathcal{N}(BM_{true,j}, \sigma_{ME})$$
$$u_{Diet} \sim \mathcal{N}(0, \sigma_{Diet})$$
$$Lifespan_j \sim \mathcal{N}(\alpha + \beta \cdot BM_{true,j} + u_{Diet[j]} + \lambda \cdot u_{phylo}, \sigma_{res})$$

This properly propagates the uncertainty in Body Mass into the regression, while also accounting for the non-independence of Diet groups and Phylogeny.

- **[Advanced Models](06_advanced_models.html)** - Random effects and interactions
- **[Model Diagnostics](09_model_diagnostics.html)** - Checking sample sizes
- **[Getting Started](01_getting_started.html)** - Basic usage
