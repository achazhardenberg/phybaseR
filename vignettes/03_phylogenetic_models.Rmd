---
title: "Phylogenetic Models"
author: "Achaz von Hardenberg"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{03. Phylogenetic Models}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

# Phylogenetic Structural Equation Models

The core strength of becauseR is combining structural equation modeling with phylogenetic comparative methods. This accounts for the non-independence of species data due to shared evolutionary history.

## Why Phylogenetic Correction?

Species are not independent data points - they share evolutionary history. Closely related species are more similar than distantly related ones, violating standard statistical assumptions.

**Without phylogenetic correction**: Inflated Type I error, incorrect parameter estimates

**With phylogenetic correction**: Proper statistical inference accounting for evolutionary relationships

## Basic Phylogenetic SEM

### Requirements

1. **Phylogenetic tree**: An `ape::phylo` object
2. **Species matching**: Tree tip labels must match data row names or ID column
3. **Structural model**: Your hypothesized causal relationships

### Simple Example

```{r, eval=FALSE}
library(becauseR)
library(ape)

# Load or create phylogeny
tree <- read.tree("my_phylogeny.nwk")

# Species data (row names = species names matching tree)
data <- data.frame(
    species = tree$tip.label,
    body_size = rnorm(length(tree$tip.label), 100, 20),
    range_size = rnorm(length(tree$tip.label), 500, 100),
    population = rnorm(length(tree$tip.label), 1000, 200),
    row.names = "species"
)

# Phylogenetic SEM
fit <- because(
    equations = list(
        range_size ~ body_size,
        population ~ range_size + body_size
    ),
    data = data,
    tree = tree, # Include phylogeny!
    dsep = TRUE,
    n.chains = 3,
    n.iter = 5000
)
```

## How It Works

### Variance-Covariance Matrix (VCV)

becauseR uses the phylogenetic VCV matrix to model evolutionary correlations:

```r
# Internally computed from your tree:
VCV <- ape::vcv.phylo(tree, corr = TRUE)

# Used in JAGS to model phylogenetic correlations
# between residuals
```

### The Model Structure

For each response variable, the model includes:

1. **Structural relationships** (your equations)
2. **Phylogenetic correlation** (from VCV matrix)
3. **Residual variance** (species-specific deviations)

**JAGS representation**:
```
# Phylogenetically structured errors
epsilon ~ MVN(0, Sigma_phylo)

# Where Sigma_phylo = sigma^2 * VCV
```

## Tree Preparation

### Matching Species

Tree tips must match data:

```{r, eval=FALSE}
# Option 1: Row names
rownames(data) <- data$species
data$species <- NULL # Remove column

# Option 2: Specify id_col
fit <- because(
    equations = equations,
    data = data,
    tree = tree,
    id_col = "species" # Column name with species IDs
)
```

### Pruning the Tree

If your data don't include all tree species:

```{r, eval=FALSE}
# Prune tree to match data
library(ape)
tree_pruned <- keep.tip(tree, rownames(data))

# Or use geiger for matching
library(geiger)
matched <- treedata(tree, data, sort = TRUE)
tree_clean <- matched$phy
data_clean <- matched$data
```

### Tree Requirements

✅ **Ultrametric**: All tips at same distance from root (for time-calibrated analyses)
✅ **Bifurcating**: No polytomies (resolve with `ape::multi2di()`)
✅ **Branch lengths**: Present and positive

**Check your tree**:
```{r, eval=FALSE}
is.ultrametric(tree) # Should be TRUE
is.binary(tree) # Should be TRUE
all(tree$edge.length > 0) # Should be TRUE
```

## Multiple Trees (Phylogenetic Uncertainty)

Account for phylogenetic uncertainty with multiple trees:

```{r, eval=FALSE}
# Load multiple trees (e.g., from BEAST posterior)
trees <- read.nexus("posterior_trees.nex")

# Sample subset for computational efficiency
sampled_trees <- sample(trees, size = 100)

# Fit model
fit <- because(
    equations = equations,
    data = data,
    tree = sampled_trees, # List of trees!
    dsep = TRUE,
    n.chains = 3,
    n.iter = 5000
)
```

**What happens**:
- Each MCMC iteration samples a random tree
- Integrates over phylogenetic uncertainty
- More robust parameter estimates

## Optimization vs. Full Bayes

### Full Bayesian (default)

```{r, eval=FALSE}
fit <- because(
    equations = equations,
    data = data,
    tree = tree,
    optimise = FALSE # Full MCMC
)
```

- Samples full posterior distribution
- Slower but complete inference
- Best for final analyses

### Optimization Mode

```{r, eval=FALSE}
fit <- because(
    equations = equations,
    data = data,
    tree = tree,
    optimise = TRUE # Faster!
)
```

- Uses VCV matrix directly in JAGS
- Much faster
- Good for exploratory analyses
- Recommended for large trees (>100 species)

## Comparing Non-Phylogenetic vs Phylogenetic

```{r, eval=FALSE}
# Model without phylogeny
fit_nophy <- because(
    equations = equations,
    data = data,
    # No tree!
    n.chains = 3,
    n.iter = 5000
)

# Model with phylogeny
fit_phy <- because(
    equations = equations,
    data = data,
    tree = tree, # With tree
    n.chains = 3,
    n.iter = 5000
)

# Compare estimates
summary(fit_nophy)
summary(fit_phy)
```

**Common patterns**:
- Phylogenetic models often have wider credible intervals (more conservative)
- Effect sizes may differ if phylogenetic signal is strong
- Non-phylogenetic models may show spurious correlations

## Phylogenetic Signal

### Lambda (Pagel's λ)

Not currently implemented in becauseR, but you can:

1. **Test beforehand** using `phytools::phylosig()`
2. **Transform tree** to reduce/increase signal:

```{r, eval=FALSE}
library(geiger)

# Reduce phylogenetic signal
tree_lambda <- rescale(tree, "lambda", 0.5) # λ = 0.5

# Use transformed tree
fit <- because(
    equations = equations,
    data = data,
    tree = tree_lambda
)
```

### When Phylogenetic Correction Matters

**High phylogenetic signal** (closely related species similar):
- Phylogenetic correction critical
- Large difference between phylo/non-phylo estimates

**Low phylogenetic signal** (species evolution independent):
- Less critical but still recommended
- Similar results with/without phylogeny

**Check signal**:
```{r, eval=FALSE}
library(phytools)

# Pagel's lambda for each variable
phylosig(tree, data$body_size, method = "lambda")
phylosig(tree, data$range_size, method = "lambda")
```

## Beyond Phylogeny: Other Covariance Structures

becauseR's `tree` argument accepts **any covariance structure**, not just phylogenies! You can model:
- Spatial autocorrelation
- Pedigrees (animal models / quantitative genetics)
- Social networks
- Custom similarity matrices

### Spatial Autocorrela

tion

Model spatial non-independence using geographic distances:

```{r, eval=FALSE}
library(sp)
library(geosphere)

# Your data with coordinates
data <- data.frame(
    site_id = 1:50,
    latitude = runif(50, 40, 50),
    longitude = runif(50, -10, 10),
    temperature = rnorm(50, 15, 3),
    species_richness = rpois(50, 20)
)

# Create spatial distance matrix
coords <- cbind(data$longitude, data$latitude)
distances <- distm(coords) / 1000 # km

# Convert to covariance (exponential decay)
spatial_sigma <- 100 # Spatial scale parameter (km)
spatial_cov <- exp(-distances / spatial_sigma)

# Ensure proper format (row names match data)
rownames(spatial_cov) <- data$site_id
colnames(spatial_cov) <- data$site_id
rownames(data) <- data$site_id

# Use as "tree" argument!
fit <- because(
    equations = list(
        species_richness ~ temperature
    ),
    data = data,
    tree = spatial_cov, # Spatial covariance matrix
    dsep = TRUE,
    n.chains = 3,
    n.iter = 5000
)
```

**What it does**: Accounts for spatial autocorrelation - nearby sites are more similar than distant ones.

**Common spatial models**:
- **Exponential**: `exp(-distance/σ)`
- **Gaussian**: `exp(-(distance/σ)²)`
- **Matérn**: More complex, flexible decay

### Pedigrees (Animal Models)

Use pedigree-based relatedness matrices for quantitative genetics:

```{r, eval=FALSE}
library(kinship2) # or nadiv

# Pedigree data
pedigree <- data.frame(
    id = 1:100,
    sire = c(NA, NA, 1, 1, 2, 2, 3, ...), # Father IDs
    dam = c(NA, NA, 2, 2, 1, 1, 4, ...) # Mother IDs
)

# Phenotype data
data <- data.frame(
    individual = 1:100,
    body_size = rnorm(100, 50, 10),
    litter_size = rpois(100, 5),
    food_availability = rnorm(100, 0, 1)
)

# Calculate additive genetic relatedness matrix (A-matrix)
ped <- pedigree(
    id = pedigree$id,
    dadid = pedigree$sire,
    momid = pedigree$dam
)
A_matrix <- kinship(ped) * 2 # A = 2 × kinship

# Ensure matching
rownames(A_matrix) <- pedigree$id
colnames(A_matrix) <- pedigree$id
rownames(data) <- data$individual

# Quantitative genetics SEM!
fit <- because(
    equations = list(
        body_size ~ food_availability,
        litter_size ~ body_size
    ),
    data = data,
    tree = A_matrix, # Genetic relatedness
    dsep = TRUE,
    n.chains = 3,
    n.iter = 5000
)
```

**What it does**: Partitions variance into genetic and environmental components, accounting for relatedness among individuals.

**Applications**:
- Heritability estimation
- Breeding values
- Genetic correlations
- Selection gradients

### Social Networks

Model dependencies from social structure:

```{r, eval=FALSE}
library(igraph)

# Social network adjacency matrix
# (who interacts with whom)
social_network <- matrix(0, 30, 30)
# ... fill with interaction data ...

# Convert to correlation matrix (or use directly)
social_cov <- cov2cor(social_network %*% t(social_network))

# Behavioral data
data <- data.frame(
    individual = 1:30,
    dominance_rank = 1:30,
    mating_success = rpois(30, 3),
    foraging_efficiency = rnorm(30, 100, 20)
)

rownames(social_cov) <- data$individual
colnames(social_cov) <- data$individual
rownames(data) <- data$individual

# Account for social structure
fit <- because(
    equations = list(
        mating_success ~ dominance_rank,
        foraging_efficiency ~ dominance_rank
    ),
    data = data,
    tree = social_cov,
    n.chains = 3,
    n.iter = 5000
)
```

### Custom Similarity Matrices

Any similarity/covariance structure works:

```{r, eval=FALSE}
# Functional similarity (trait-based)
# Morphological distances
# Ecological niche overlap
# Genomic similarity (SNPs)
# Temporal autocorrelation

# Just ensure:
# 1. Symmetric matrix
# 2. Positive semi-definite
# 3. Row/column names match data
# 4. Diagonal typically = 1 (correlation) or max (covariance)

custom_cov <- your_similarity_function(data)
rownames(custom_cov) <- data$id
colnames(custom_cov) <- data$id

fit <- because(
    equations = equations,
    data = data,
    tree = custom_cov,
    n.chains = 3,
    n.iter = 5000
)
```

### Multiple Covariance Structures

Combine phylogeny with other structures using random effects:

```{r, eval=FALSE}
# Phylogeny for species + random effects for space
fit <- because(
    equations = list(
        trait ~ environment + (1 | site)
    ),
    data = data,
    tree = phylo_tree, # Phylogenetic correlation
    random = ~ (1 | site), # Spatial grouping
    n.chains = 3,
    n.iter = 5000
)
```

**Or** provide multiple matrices (advanced - may require custom JAGS):

```{r, eval=FALSE}
# Phylogenetic + spatial
# Genetic + environmental
# Multiple levels of structure
```

### Requirements for Custom Matrices

✅ **Symmetric**: `all(cov_matrix == t(cov_matrix))`  
✅ **Positive semi-definite**: All eigenvalues ≥ 0  
✅ **Proper dimensions**: n × n for n observations  
✅ **Named**: Row/column names match data IDs  
✅ **Scaled appropriately**: Typically correlation matrix (diagonal = 1)  

**Check your matrix**:
```{r, eval=FALSE}
# Is it symmetric?
isSymmetric(my_matrix)

# Is it positive semi-definite?
all(eigen(my_matrix)$values >= -1e-8) # Allow tiny negative for numerical error

# Are dimensions correct?
nrow(my_matrix) == nrow(data)

# Do names match?
all(rownames(my_matrix) %in% rownames(data))
```

## Combining with Other Features

### Phylogenetic + Random Effects

```{r, eval=FALSE}
# Account for phylogeny AND repeated measures
fit <- because(
    equations = list(
        trait ~ environment + (1 | population)
    ),
    data = data,
    tree = tree,
    random = ~ (1 | species), # Additional random effect
    n.chains = 3,
    n.iter = 5000
)
```

### Phylogenetic + Hierarchical Data

```{r, eval=FALSE}
# Species-level phylogeny with individual-level data
fit <- because(
    data = list(
        species = species_data,
        individual = individual_data
    ),
    levels = list(
        species = c("range_size", "habitat"),
        individual = c("body_mass", "age")
    ),
    hierarchy = "species > individual",
    link_vars = "species_id",
    tree = tree, # Applied at species level
    equations = equations
)
```

## Troubleshooting

### Error: "Tree tips don't match data"

**Solution**: Check matching
```{r, eval=FALSE}
# What's in tree?
tree$tip.label

# What's in data?
rownames(data) # or data$species

# Find mismatches
setdiff(tree$tip.label, rownames(data)) # In tree but not data
setdiff(rownames(data), tree$tip.label) # In data but not tree
```

### Error: "Tree is not ultrametric"

**Solution**: Make ultrametric
```{r, eval=FALSE}
library(ape)
tree_ultra <- chronos(tree) # Date the tree
```

### Warning: "Tree has polytomies"

**Solution**: Resolve polytomies
```{r, eval=FALSE}
tree_binary <- multi2di(tree) # Randomly resolve
```

### Poor convergence with large trees

**Solution**: Use optimization
```{r, eval=FALSE}
fit <- because(
    equations = equations,
    data = data,
    tree = tree,
    optimise = TRUE, # Much faster for large trees
    n.chains = 3,
    n.iter = 5000
)
```

## Best Practices

1. **Always visualize your tree first**
```{r, eval=FALSE}
plot(tree)
```

2. **Check tree-data matching carefully**
3. **Start with optimization mode** for large trees
4. **Compare phylo vs non-phylo** to assess impact
5. **Test phylogenetic signal** in your traits
6. **Use multiple trees** if available (phylogenetic uncertainty)

## See Also

- **[Getting Started](01_getting_started.html)** - Basic usage
- **[Advanced Models](06_advanced_models.html)** - Random effects and polynomials
- **[Model Diagnostics](09_model_diagnostics.html)** - Interpreting results
- **[Latent Variables](08_latent_variables.html)** - Measurement models
