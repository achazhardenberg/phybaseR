---
title: "Alternative Covariance Structures"
author: "Achaz von Hardenberg"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{04. Alternative Covariance Structures}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

# Beyond Phylogeny: Alternative Covariance Structures

becauseR's `tree` argument accepts **any covariance structure**, not just phylogenies. This enables modeling:

- **Spatial autocorrelation** (geographic dependencies)
- **Pedigrees** (animal models / quantitative genetics)
- **Social networks** (behavioral dependencies)
- **Temporal autocorrelation** (time series)
- **Custom similarity matrices** (any correlation structure)

---

## Why Model Covariance Structure?

Similar to phylogenetic non-independence, other structures create correlations among observations:

- **Spatial**: Nearby sites are more similar
- **Genetic**: Related individuals share alleles
- **Social**: Connected individuals influence each other
- **Temporal**: Adjacent time points are correlated

**Ignoring structure** → Inflated Type I error, wrong estimates  
**Modeling structure** → Proper inference, correct uncertainty

---

## Spatial Autocorrelation

Account for geographic dependencies in your data.

### Basic Spatial Model

```{r, eval=FALSE}
library(geosphere) # For distance calculations

# Data with coordinates
data <- data.frame(
    site_id = 1:50,
    latitude = runif(50, 40, 50),
    longitude = runif(50, -10, 10),
    temperature = rnorm(50, 15, 3),
    species_richness = rpois(50, 20),
    habitat_quality = rnorm(50, 0, 1)
)

# Calculate geographic distances
coords <- cbind(data$longitude, data$latitude)
distances <- distm(coords) / 1000 # Convert to km

# Create spatial covariance matrix (exponential decay)
spatial_sigma <- 100 # Spatial scale (km)
spatial_cov <- exp(-distances / spatial_sigma)

# Format for becauseR
rownames(spatial_cov) <- data$site_id
colnames(spatial_cov) <- data$site_id
rownames(data) <- data$site_id

# Fit model with spatial structure
fit <- because(
    equations = list(
        species_richness ~ temperature + habitat_quality
    ),
    data = data,
    tree = spatial_cov, # Spatial covariance!
    dsep = TRUE,
    n.chains = 3,
    n.iter = 5000
)
```

### Spatial Correlation Functions

Different functions for different spatial patterns:

#### Exponential Decay
```{r, eval=FALSE}
# Sharp initial decline, long tail
spatial_cov <- exp(-distances / sigma)
```

**Use when**: Gradual spatial gradients

#### Gaussian Decay
```{r, eval=FALSE}
# Smooth, faster decay at distance
spatial_cov <- exp(-(distances / sigma)^2)
```

**Use when**: Strong local correlation, weak distant correlation

#### Matérn Correlation
```{r, eval=FALSE}
library(geoR)

# More flexible, controls smoothness
spatial_cov <- matern(distances, phi = sigma, kappa = 1.5)
```

**Use when**: Need to control smoothness parameter

### Choosing Spatial Scale (σ)

```{r, eval=FALSE}
# Exploratory: variogram
library(gstat)
library(sp)

coordinates(data) <- ~ longitude + latitude
variogram_emp <- variogram(species_richness ~ 1, data)
plot(variogram_emp)

# Fit variogram to estimate range
vgm_fit <- fit.variogram(variogram_emp, vgm("Exp"))
sigma_estimate <- vgm_fit$range[2]
```

---

## Pedigrees (Animal Models)

Quantitative genetics using pedigree-based relatedness.

### Basic Animal Model

```{r, eval=FALSE}
library(kinship2) # Or nadiv, pedigreemm

# Pedigree structure
pedigree <- data.frame(
    id = 1:100,
    sire = c(NA, NA, rep(1:10, each = 10), ...), # Father IDs
    dam = c(NA, NA, rep(11:20, each = 10), ...) # Mother IDs
)

# Phenotype data
data <- data.frame(
    individual = 1:100,
    body_size = rnorm(100, 50, 10),
    litter_size = rpois(100, 5),
    maternal_care = rnorm(100, 0, 1),
    food_availability = rnorm(100, 0, 1)
)

# Calculate additive genetic relatedness matrix (A-matrix)
ped_obj <- pedigree(
    id = pedigree$id,
    dadid = pedigree$sire,
    momid = pedigree$dam
)
A_matrix <- kinship(ped_obj) * 2 # A = 2 × kinship

# Ensure matching
rownames(A_matrix) <- pedigree$id
colnames(A_matrix) <- pedigree$id
rownames(data) <- data$individual

# Quantitative genetics SEM!
fit <- because(
    equations = list(
        body_size ~ food_availability + maternal_care,
        litter_size ~ body_size + maternal_care
    ),
    data = data,
    tree = A_matrix, # Genetic relatedness
    dsep = TRUE,
    n.chains = 3,
    n.iter = 5000
)
```

### What the A-Matrix Captures

- **Diagonal**: 1 (individual's relatedness to itself)
- **Parent-offspring**: 0.5 (share 50% genes)
- **Full siblings**: 0.5 on average
- **Half siblings**: 0.25
- **Unrelated**: 0

### Applications

**Heritability estimation**:
```{r, eval=FALSE}
# Variance components from model
# h² = V_genetic / (V_genetic + V_residual)
```

**Breeding values** for selection:
```{r, eval=FALSE}
# Genetic merit of individuals
# Used in animal/plant breeding
```

**Genetic correlations**:
```{r, eval=FALSE}
# Are traits genetically correlated?
fit <- because(
    equations = list(
        trait1 ~ environment,
        trait2 ~ environment
    ),
    data = data,
    tree = A_matrix
)
# Correlation in genetic effects
```

### Advanced: Dominance & Epistasis

```{r, eval=FALSE}
# Additive + dominance
library(nadiv)
D_matrix <- makeD(pedigree) # Dominance relatedness

# Would need custom JAGS to include both A and D
```

---

## Social Networks

Model dependencies from social structure.

### Network-Based Covariance

```{r, eval=FALSE}
library(igraph)

# Social network adjacency matrix
# 1 = individuals interact, 0 = no interaction
social_adj <- matrix(0, 30, 30)
# Fill with observed interactions
social_adj[1, 2] <- 1
social_adj[2, 1] <- 1
# ... etc

# Convert to covariance
# Option 1: Direct adjacency as correlation
social_cov <- social_adj
diag(social_cov) <- 1

# Option 2: Normalized Laplacian
graph <- graph_from_adjacency_matrix(social_adj, mode = "undirected")
laplacian <- laplacian_matrix(graph, normalized = TRUE)
social_cov <- solve(laplacian + diag(0.1, nrow(laplacian))) # Regularize

# Behavioral data
data <- data.frame(
    individual = 1:30,
    dominance_rank = sample(1:30),
    mating_success = rpois(30, 3),
    foraging_efficiency = rnorm(30, 100, 20),
    aggression = rnorm(30, 0, 1)
)

rownames(social_cov) <- data$individual
colnames(social_cov) <- data$individual
rownames(data) <- data$individual

# SEM with social structure
fit <- because(
    equations = list(
        mating_success ~ dominance_rank + aggression,
        foraging_efficiency ~ dominance_rank
    ),
    data = data,
    tree = social_cov,
    n.chains = 3,
    n.iter = 5000
)
```

### Network Metrics as Covariates

```{r, eval=FALSE}
# Instead of (or in addition to) covariance structure
g <- graph_from_adjacency_matrix(social_adj)

data$degree <- degree(g) # Number of connections
data$betweenness <- betweenness(g) # Bridging position
data$eigenvector <- eigen_centrality(g)$vector # Influence

# Use as predictors
fit <- because(
    equations = list(
        mating_success ~ degree + betweenness
    ),
    data = data,
    tree = social_cov # Still account for network structure
)
```

---

## Temporal Autocorrelation

For time series or repeated measures over time.

### AR(1) Correlation Structure

```{r, eval=FALSE}
# Data ordered by time
data <- data.frame(
    time = 1:100,
    measurement = arima.sim(list(ar = 0.7), n = 100),
    temperature = rnorm(100, 15, 3),
    rainfall = rnorm(100, 50, 20)
)

# AR(1) correlation matrix
rho <- 0.7 # Autocorrelation parameter
n <- nrow(data)
temporal_cov <- rho^abs(outer(1:n, 1:n, "-"))

rownames(temporal_cov) <- data$time
colnames(temporal_cov) <- data$time
rownames(data) <- data$time

fit <- because(
    equations = list(
        measurement ~ temperature + rainfall
    ),
    data = data,
    tree = temporal_cov,
    n.chains = 3,
    n.iter = 5000
)
```

### Estimating ρ

```{r, eval=FALSE}
# From data
acf(data$measurement, plot = FALSE)$acf[2] # Lag-1 autocorrelation

# Or use nlme/lme4 first
library(nlme)
temp_fit <- gls(measurement ~ temperature + rainfall,
    correlation = corAR1(form = ~time),
    data = data
)
rho_est <- coef(temp_fit$modelStruct$corStruct, unconstrained = FALSE)
```

---

## Custom Similarity Matrices

Any symmetric, positive semi-definite matrix works.

### Functional Trait Similarity

```{r, eval=FALSE}
# Species functional traits
traits <- data.frame(
    species = paste0("sp", 1:50),
    bill_length = rnorm(50, 20, 5),
    wing_length = rnorm(50, 100, 20),
    body_mass = rnorm(50, 50, 15)
)

# Euclidean distance in trait space
trait_matrix <- as.matrix(traits[, -1])
trait_dist <- dist(trait_matrix)
trait_dist_matrix <- as.matrix(trait_dist)

# Convert distance to similarity (Gaussian kernel)
sigma_trait <- median(trait_dist_matrix)
functional_sim <- exp(-(trait_dist_matrix / sigma_trait)^2)

rownames(functional_sim) <- traits$species
colnames(functional_sim) <- traits$species

# Use in SEM
fit <- because(
    equations = equations,
    data = data,
    tree = functional_sim,
    n.chains = 3,
    n.iter = 5000
)
```

### Genomic Similarity (SNPs)

```{r, eval=FALSE}
# Genomic relationship matrix from SNPs
library(rrBLUP)

# SNP data (individuals × markers)
snps <- matrix(sample(0:2, 100 * 1000, replace = TRUE), 100, 1000)
rownames(snps) <- paste0("ind", 1:100)

# Calculate genomic relationship matrix
G_matrix <- A.mat(snps - 1) # Center & scale

fit <- because(
    equations = equations,
    data = data,
    tree = G_matrix,
    n.chains = 3,
    n.iter = 5000
)
```

---

## Combining Multiple Structures

### Phylogeny + Spatial

```{r, eval=FALSE}
# Can't pass two matrices to tree argument
# Use one as tree, other as random effect

fit <- because(
    equations = list(
        trait ~ environment + (1 | site)
    ),
    data = data,
    tree = phylo_tree, # Phylogenetic structure
    random = ~ (1 | site), # Spatial grouping
    n.chains = 3,
    n.iter = 5000
)
```

### Multiple Random Effects

```{r, eval=FALSE}
# Phylogeny + Genetic + Spatial
fit <- because(
    equations = list(
        trait ~ environment + (1 | population) + (1 | site)
    ),
    data = data,
    tree = phylo_tree, # Species phylogeny
    random = ~ (1 | population) + (1 | site), # Other structures
    n.chains = 3,
    n.iter = 5000
)
```

---

## Requirements for Custom Matrices

Your covariance matrix must satisfy:

✅ **Symmetric**: `all(cov_matrix == t(cov_matrix))`  
✅ **Positive semi-definite**: All eigenvalues ≥ 0  
✅ **Proper dimensions**: n × n for n observations  
✅ **Named rows/columns**: Match data identifiers  
✅ **Appropriate scale**: Typically correlation matrix (diagonal = 1)  

### Validation Checks

```{r, eval=FALSE}
validate_covariance_matrix <- function(mat, data) {
    # Symmetry
    if (!isSymmetric(mat)) {
        stop("Matrix is not symmetric")
    }

    # Positive semi-definite
    eigs <- eigen(mat, only.values = TRUE)$values
    if (any(eigs < -1e-8)) { # Allow tiny numerical error
        warning("Matrix may not be positive semi-definite")
    }

    # Dimensions
    if (nrow(mat) != nrow(data)) {
        stop("Matrix dimensions don't match data")
    }

    # Names
    if (!all(rownames(mat) %in% rownames(data))) {
        stop("Matrix rownames don't match data rownames")
    }

    message("✓ Matrix passed validation")
    return(TRUE)
}

# Use before fitting
validate_covariance_matrix(my_cov_matrix, data)
```

---

## Troubleshooting

### Matrix Not Positive Semi-Definite

**Problem**: Negative eigenvalues

**Solutions**:
```{r, eval=FALSE}
# 1. Add small value to diagonal
mat_fixed <- mat + diag(0.01, nrow(mat))

# 2. Nearest positive semi-definite matrix
library(Matrix)
mat_fixed <- nearPD(mat)$mat

# 3. Check for errors in calculation
```

### Poor Convergence

**Problem**: Model doesn't converge

**Solutions**:
- Simplify structure (fewer off-diagonals)
- Scale matrix (diagonal = 1)
- More iterations
- Check if structure is appropriate for data

### Computational Speed

**Problem**: Large matrices slow

**Solutions**:
```{r, eval=FALSE}
# Use sparse matrices
library(Matrix)
sparse_cov <- as(cov_matrix, "dgCMatrix")

# Optimize mode
fit <- because(..., optimise = TRUE)

# Reduce matrix size (subsample)
```

---

## See Also

- **[Phylogenetic Models](03_phylogenetic_models.html)** - Special case of covariance structure
- **[Advanced Models](06_advanced_models.html)** - Random effects  
- **[Getting Started](01_getting_started.html)** - Basic usage
- **[Model Diagnostics](09_model_diagnostics.html)** - Model checking
